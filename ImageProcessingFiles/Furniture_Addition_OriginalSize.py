import cv2

# this function perform main analysis on furniture image
# it takes one argument which is path to furniture image
# it returns nothing but saving the results (two output images) in (Furniture_with_black_background.png, Furniture_mask.png)

def Furniture_Analysis(Furniture_Path):
    # read the furniture image and store it then make a copy of it
    Furniture_original_image = cv2.imread(Furniture_Path)
    Furniture_image_copy = Furniture_original_image.copy()
    
    # convert it into gray scale image, then make it black and white
    # the idea here is that I want to make a mask from the input (furniture image), to just add it to the room image.
    # So I converted it to gray scale image, then convert it into black and white image to make it easier for canny to detect
    # its edges and to get the best results.
    
    gray = cv2.cvtColor(Furniture_image_copy, cv2.COLOR_BGR2GRAY)
    (_, black_And_White_Image) = cv2.threshold(gray, 200, 255, cv2.THRESH_BINARY)
    cany = cv2.Canny(black_And_White_Image, 20, 170)
    
    # After detecting edges I've used contours to fill the area between the edges (to make a mask)
    # So I've detected contours, then draw it.
    contours, hirachey = cv2.findContours(cany, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_NONE)

    for contour in contours:
        cv2.drawContours(Furniture_image_copy, contour, cv2.FILLED, (0, 0, 0), 3)
    
    # here I wanted to have a mask (black shape with a white background) and an image with the same size as the mask but
    # (orginal shape with black background)
    gray_image = cv2.cvtColor(Furniture_image_copy, cv2.COLOR_BGR2GRAY)
    (thresh, blackAndWhiteImage) = cv2.threshold(gray_image, 200, 255, cv2.THRESH_BINARY)
    not_blackAndWhiteImage = cv2.bitwise_not(blackAndWhiteImage)
    Furniture_with_black_background = cv2.bitwise_and(Furniture_original_image, Furniture_original_image,
                                                      mask=not_blackAndWhiteImage)
    
    # here I'm just storing the results
    cv2.imwrite("Furniture_with_black_background.png", Furniture_with_black_background)
    cv2.imwrite("Furniture_mask.png", blackAndWhiteImage)


def nothing(x):
    print(x)

#this pointer which holds the cropped points
refPt = []

# callback function for mouse event
def click_and_crop(event, x, y, flags, param):
    global refPt
    # if user pressed left mouse, then store its starting points (x,y)
    if event == cv2.EVENT_LBUTTONDOWN:
        refPt = [(x, y)]
    # on release store last (x,y) in refpt
    elif event == cv2.EVENT_LBUTTONUP:
        refPt.append((x, y))

# this function Adds the funiture to the image, but with furniture original size, user can't resize it.
# he/she will just choose the place and we will put it.
# this function takes two arguments, room image and (Furniture_image_path) which passed to (Furniture_Analysis) function.
# it returns nothing but showing the final image.
def Adding_Furniture_with_original_size(image, Furniture_image_path):
    Furniture_Analysis(Furniture_image_path)
    
    cv2.namedWindow("image")
    clone = image.copy()
    cv2.namedWindow("image")
    cv2.setMouseCallback("image", click_and_crop)

    while True:
        cv2.imshow("image", image)
        key = cv2.waitKey(1) & 0xFF
        if key == ord("c"):
            break

    roi = clone[refPt[0][1]:refPt[1][1], refPt[0][0]:refPt[1][0]]
    Furniture_with_black_background = cv2.imread("Furniture_with_black_background.png")
    Furniture_mask = cv2.imread("Furniture_mask.png")

    y_center = refPt[0][1]
    x_center = refPt[0][0]
    
    # here in this part it takes the furniture dimensions and stores it, then depending on points which we got from the user
    # I will get new coordinates based on (Furniture_with_black_background) dimensions.
    # then I will crop this region and stores it in cutted_image.
    y, x, _ = Furniture_with_black_background.shape

    top_x = int(x_center - (x / 2))
    top_y = int(y_center - (y / 2))

    cutted_image = image[top_y:top_y+y, top_x:top_x+x]
    
    # this part is just adding the masked image (which was generated by the previous function), (and) it with cutted_image.
    # then I will or with (Furniture_with_black_background) to get the desired output.
    Out_Image = cv2.bitwise_and(cutted_image,Furniture_mask)
    Final_Out = cv2.bitwise_or(Furniture_with_black_background, Out_Image)
    
    # this part just adds the result to the image, then shows it.
    image[top_y:top_y+y, top_x:top_x+x] = Final_Out

    cv2.imshow("image", image)
    cv2.waitKey()


image = cv2.imread("Room.jpg")
Adding_Furniture_with_original_size(image, "knba.jpg")
